# -*- coding: utf-8 -*-
"""read_data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ua06IkbPt75__NGn2mn612IMU5RwUZXm
"""

import os
import glob
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from scipy import odr
import pickle


class LettuceDataset(object):

    def __init__(self, train_folder, tmp_folder):
        self.train_folder = train_folder
        self.tmp_folder = tmp_folder

    def crop_weight(self, t):
        cm = 20
        rm = 0.14
        tb = 35.4
        w = cm/rm*np.log(1+np.exp(rm*(t-tb)))
        return w

    def growth_rate(self, w):
        cm = 20
        k = 0.7
        p1 = 0.5
        s = 0.02
        c = cm*(1-np.exp(-k*p1*s*w))
        return c

    def f_co2(self, co2):
        beta_co2 = 400
        return 1 - np.exp(-co2 / beta_co2)

    def f_par(self, par):
        beta_par = 200
        return 1 - np.exp(-par / beta_par)

    def f_t(self, t):
        t_opt = 25
        t_diff = np.abs(t - t_opt)
        t_rng = 25
        return np.array([1 - (t_d/t_rng)**2 if t_d < t_rng else 0 for t_d in t_diff])

    def g(self, g_r, co2_r, par_r, t_r):
        g_r = np.array(list(g_r))
        co2_r = np.array(list(co2_r))
        par_r = np.array(list(par_r))
        t_r = np.array(list(t_r))
        return g_r * co2_r * par_r * t_r

    def read_data(self, train_folder):
        x_file_list = sorted(glob.glob(train_folder + '/*X.csv'))
        y_file_list = sorted(glob.glob(train_folder + '/*monitor.csv'))

        for file in x_file_list:
            if 'reference' in file:
                x_file_list.remove(file)

        for file in y_file_list:
            if 'reference' in file:
                y_file_list.remove(file)

        data = []
        for x_file, y_file in zip(x_file_list, y_file_list):
            X = pd.read_csv(x_file, index_col=0).values
            Y = pd.read_csv(y_file, index_col=0).values
            data.append((X, Y))
        return data

    def minmaxnormalize(self, data):
        min = data.min()
        max = data.max()
        max = 1 if max <= 0 else max
        data_norm = (data - min) / (max - min)
        return data_norm

    def control_process(self, X):
        vent = X[:, 1]
        lamp = X[:, 2]
        scr_eng = X[:, 3]
        scr_black = X[:, 4]
        vent_norm = self.minmaxnormalize(vent).reshape(-1, 1)
        lamp_norm = self.minmaxnormalize(lamp).reshape(-1, 1)
        scr_eng_norm = self.minmaxnormalize(scr_eng).reshape(-1, 1)
        scr_black_norm = self.minmaxnormalize(scr_black).reshape(-1, 1)
        cont_norm = np.hstack((vent_norm, lamp_norm, scr_eng_norm, scr_black_norm))
        return np.concatenate((X[:, [0]], cont_norm, X[:, [-1]]), axis=1)

    def data_process(self, data):
        simulator_model_path = os.path.join(self.tmp_folder, 'model')
        if not os.path.exists(simulator_model_path):
            os.makedirs(simulator_model_path)

        if len(data) == 0:
            return []

        days = 48
        # d = np.array(range(days))

        train_X_list = []
        train_Y_list = []

        for i in data:
            X, Y = i
            n = Y.shape[0]

            x_df = pd.DataFrame(X)
            x_df = x_df.fillna(method='ffill')
            X = x_df.values

            y_df = pd.DataFrame(Y)
            y_df = y_df.fillna(method='ffill')
            Y = y_df.values

            # Tout, Rhout, Iglob, Windsp, PARout
            outside_weather = pd.read_csv(self.train_folder + '/weather.csv', index_col=0)
            outside_weather = outside_weather.fillna(method='ffill').values

            if not os.path.exists(os.path.join(simulator_model_path, 'weather.npy')):
                np.save(os.path.join(simulator_model_path,
                                     'weather.npy'), outside_weather)

            # heating_temp_vip, lee_wind_min_vip, assim_vip, scr_enrg_vip, scr_blck_vip, CO2_vip
            control = self.control_process(X)
            inside_weather = Y[:, [0, 1, 2]]  # Tair, Rhair, CO2air

            '''FW expolinear growth equation'''
            # fw = self.crop_weight(d)
            # c = self.growth_rate(fw)
            #
            # fw_model = odr.polynomial(5)
            # FW = odr.Data(d, fw)
            # odr_fw = odr.ODR(FW, fw_model)
            # output = odr_fw.run()  # running ODR fitting
            # poly = np.poly1d(output.beta[::-1])
            # poly_fw = poly(np.linspace(0, days, n)).reshape(-1, 1)
            #
            # c_model = odr.polynomial(5)
            # C = odr.Data(d, c)
            # odr_c = odr.ODR(C, c_model)
            # output2 = odr_c.run()  # running ODR fitting
            # poly = np.poly1d(output2.beta[::-1])
            # poly_c = poly(np.linspace(0, days, n))
            # poly_c = (poly_c - poly_c.min())/(poly_c.max() - poly_c.min())
            # crop_state = poly_c.reshape(-1, 1)

            '''Growth model'''
            T = Y[:, 0]
            CO2 = Y[:, 2]
            PAR = Y[:, 3]

            t_r = self.f_t(T)  # temperature growth factor [0,1]
            co2_r = self.f_co2(CO2)  # co2 growth factor [0,1]
            par_r = self.f_par(PAR)  # light PAR growth factor [0,1]
            max_gr = [1.194 ** (1/12)] * n  # maximum hourly growth rate
            crop_state = self.g(max_gr, co2_r, par_r, t_r).reshape(-1, 1)  # hourly growth rate
            fw = (np.cumprod(1 + crop_state) * 2.5e-115).reshape(-1, 1)  # fresh weight

            '''PARsensor linear regression'''
            # Iglob, PARout, lamp
            par_x = np.hstack((outside_weather[:, [2, 4]], control[:, [2]]))

            if not os.path.exists(os.path.join(simulator_model_path, 'PARsensor_regression_parameters.pkl')):
                par_y = Y[:, 3]  # PARin
                linreg = LinearRegression()
                linreg.fit(par_x, par_y)
                pickle.dump(linreg,
                            open(os.path.join(simulator_model_path, 'PARsensor_regression_parameters.pkl'), 'wb'))
            else:
                linreg = pickle.load(
                    open(os.path.join(simulator_model_path, 'PARsensor_regression_parameters.pkl'), 'rb'))
            PARsensor = linreg.predict(par_x)
            PARsensor = np.where(PARsensor > 50.0, PARsensor, 0)
            PARsensor = PARsensor.reshape(len(Y), -1)

            train_X = np.hstack(
                (outside_weather, control, inside_weather, PARsensor, crop_state, fw))[:-1]
            train_Y = np.hstack((inside_weather, crop_state, fw))[1:]

            train_X_list.append(train_X)
            train_Y_list.append(train_Y)

        train_X_all = np.array(train_X_list)
        train_Y_all = np.array(train_Y_list)

        return train_X_all, train_Y_all

    def PAR_x_y(self, X, Y):
        # Iglob, PARout, lamp
        train_X = np.concatenate(X[:, :, [2, 4, 7]], axis=0)
        train_Y = np.concatenate(X[:, :, 14])
        return train_X, train_Y

    def greenhouse_x_y(self, X, Y):

        train_X = np.concatenate(X[:, :, :14], axis=0)
        train_Y = np.concatenate(Y[:, :, :3], axis=0)

        return train_X, train_Y

    def crop_front_x_y(self, X, Y):

        train_X = np.concatenate(X[:, :, 11:16], axis=0)
        train_Y = np.concatenate(Y[:, :, [3]], axis=0)
        # print('x', train_X)
        # print('crop', train_Y)

        return train_X, train_Y

    def crop_back_x_y(self, X, Y):

        DAY_IN_LIFE_CYCLE = 48
        day_index = [23 + i * 24 for i in range(DAY_IN_LIFE_CYCLE - 1)]
        day_index_plus = [23 + (i + 1) * 24 for i in range(DAY_IN_LIFE_CYCLE - 1)]
        train_X = np.concatenate(X[:, day_index, -2:], axis=0)
        # print('x', train_X)
        train_Y = np.concatenate(X[:, day_index_plus, -1], axis=0)
        # print('y', train_Y)
        train_Y = train_Y.reshape(len(train_Y), -1)

        return train_X, train_Y


if __name__ == '__main__':
    pass